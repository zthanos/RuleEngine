using Newtonsoft.Json.Schema;
using RuleEngineAPI.Application.Commands;
using RuleEngineAPI.Application.Events;
using RuleEngineAPI.Domain.Aggregates;
using RuleEngineAPI.Domain.Interfaces;
using RuleEngineAPI.Infrastructure.Interfaces;
using RuleEngineAPI.Infrastructure.Services;

namespace RuleEngineAPI.Application.Services;

public interface IRuleProcessingService
{
    public Task ProcessCreateRuleForType(CreateRuleForTypeCommand command);
    Task<RuleExecutionResults> ProcessRuleExecution(ExecuteRuleCommand command);
}

public class RuleProcessingService(
    IEventStore eventStore,
    IRuleManagerService ruleManagerService,
    IRuleSetRepository ruleSetRepository,
    IRuleStorageService storageService) : IRuleProcessingService
{
    private readonly IEventStore _eventStore = eventStore;
    private readonly IRuleManagerService _ruleManagerService = ruleManagerService;
    private readonly IRuleSetRepository _ruleSetRepository = ruleSetRepository;
    private readonly IRuleStorageService _storageService= storageService;
    public async Task ProcessCreateRuleForType(CreateRuleForTypeCommand command)
    {
        //var schema = JSchema.Parse(command.Schema);
        //var rules = _ruleManagerService.ParseRules(command.InitialRules, schema);

        var ruleSet = new RuleSet();
        ruleSet.CreateRuleForType(_ruleManagerService,
            command.RuleSetId,
            command.TypeToApply,
            command.InitialRules,
            command.Schema,
        command.Version);

        var uncommittedEvents = ruleSet.GetUncommittedEvents();
        foreach (IEvent ruleSetCreatedEvent in uncommittedEvents)
        {
            if (ruleSetCreatedEvent is RuleSetCreated ruleSetCreated)
            {
                await _eventStore.AppendEventAsync(ruleSet.AggregateId, ruleSetCreated);

                await _storageService.StoreRule(
                    command.Version,
                    command.TypeToApply,
                    command.InitialRules,
                    command.Schema,
                    ruleSetCreated.AvailableRules);
            }

        }
        ruleSet.ClearUncommittedEvents();
    }

    public async Task<RuleExecutionResults> ProcessRuleExecution(ExecuteRuleCommand command)
    {
        // Retrieve stream by TypeToApplyRule since this is equal to Stream Id
        RuleSet ruleSet = await _ruleSetRepository.GetByIdAsync(command.TypeToApplyRule);

        if (ruleSet != null)
        {
            // Execute the rule using the provided rule manager service
            var executionResult = ruleSet.ExecuteRule(command.Id, _ruleManagerService, command.JsonData);

            // Process and persist uncommitted events generated by rule execution
            var uncommittedEvents = ruleSet.GetUncommittedEvents();
            foreach (IEvent ruleExecutedEvent in uncommittedEvents)
            {
                await _eventStore.AppendEventAsync(ruleSet.AggregateId + "-execute", ruleExecutedEvent);
            }
            ruleSet.ClearUncommittedEvents();
            return executionResult;
        }
        else
        {
            // Handle the case where the RuleSet is not found, possibly logging or throwing an exception
            // Log.Error($"RuleSet not found for TypeToApplyRule: {command.TypeToApplyRule}");
            throw new InvalidOperationException($"RuleSet not found for TypeToApplyRule: {command.TypeToApplyRule}");
        }
    }

}
